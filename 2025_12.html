<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="initial-scale=1"><meta name="description" content="The Koi Farm 2 development blog"><title>Koi Farm 2 blog | December 2025</title><link rel="icon" type="image/png" sizes="16x16" href="favicon_16.png"/><link rel="icon" type="image/png" sizes="32x32" href="favicon_32.png"/><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="rss.xml"><style>:root {--color-background: #e6e8d2;--color-content: #efefef;--color-dark: #2f2f2f;--color-link: #5488cc;--color-hover: #4ba837;--width: 1000px;--body-margin: 8px;--menu-toggle-width: 80px;--menu-toggle-height: 24px;}a:link {color: var(--color-link);}a:visited {color: var(--color-link);}a:hover {color: var(--color-hover);}.icon {float: right;margin-left: 4px;fill: var(--color-dark);}.icon:hover {fill: var(--color-hover);}body {background-color: var(--color-background);color: var(--color-dark);font-family: serif;margin: var(--body-margin);font-size: 12pt;}#wrapper {max-width: var(--width);margin-left: auto;margin-right: auto;}#header {text-align: right;}#content {display: flex;justify-content: center;}#index {padding: 12px;white-space: nowrap;}#index ul {list-style-type: none;text-align: right;margin: 0;}#index svg {width: 20px;height: 20px;}#blog {flex-grow: 1;}#post {background-color: var(--color-content);padding: 12px;display: inline-block;border: 1px solid var(--color-dark);}#post h2 {margin: 0;text-align: center;width: 100%;font-size: 20pt;}#post h3 {text-align: center;width: 100%;font-size: 10pt;margin-top: 0;font-style: italic;font-weight: normal;}#post figure {float: right;clear: right;}#post img {max-width: 100%;height: auto;}#post video {max-width: 100%;}#footer {margin-bottom: 24px;padding: var(--body-margin);display: flex;justify-content: space-between;}#footer .next {float: right;}#copyright {font-size: 10pt;font-weight: normal;color: rgba(0, 0, 0, 0.47);}.dropdown-checkbox {display: none;}.dropdown-menu {display: none;}.dropdown-checkbox:checked ~ .dropdown-menu {display: block;}.dropdown-checkbox:checked ~ #menu-toggle span:before {content: "Index ▲";}#menu-toggle {position: fixed;right: 0;width: var(--menu-toggle-width);height: var(--menu-toggle-height);margin: var(--body-margin);background-color: var(--color-content);border: 1px solid var(--color-dark);flex-direction: column;user-select: none;display: flex;align-items: center;justify-content: center;box-sizing: border-box;}#menu-toggle:hover {cursor: pointer;}#menu-toggle span:before {content: "Index ▼";}@media (max-width: 1000px) {body {margin: 0;}#post h2 {margin-top: 24px;}#index {position: fixed;right: 0;top: calc(var(--menu-toggle-height) - 1px);margin: var(--body-margin);background-color: var(--color-content);border: 1px solid var(--color-dark);max-height: 80%;overflow: auto;}#post {border-left: none;border-right: none;border-top: none;border-bottom: 1px solid var(--color-dark);}}@media (min-width: 1001px) {#index {display: block;}#menu-toggle {display: none;}}</style></head><body><div id="wrapper"><div id="content"><input type="checkbox" id="dropdown-menu" class="dropdown-checkbox"><label for="dropdown-menu" id="menu-toggle"><span></span></label><div id="index" class="dropdown-menu"><ul><li>December 2025</li><li><a title="Terrain detailing" href="2025_11.html">November 2025</a></li><li><a title="A tiny distraction" href="2025_10.html">October 2025</a></li><li><a title="Grass" href="2025_09.html">September 2025</a></li><li><a title="Holland Koi Show" href="2025_08.html">August 2025</a></li><li><a title="Shadows" href="2025_07.html">July 2025</a></li><li><a title="Making waves" href="2025_06.html">June 2025</a></li><li><a title="The grid" href="2025_05.html">May 2025</a></li><li><a title="Tessellation" href="2025_04.html">April 2025</a></li><li><a title="Patterns" href="2025_03.html">March 2025</a></li><li><a title="Memory management" href="2025_02.html">February 2025</a></li><li><a title="The koi are back" href="2025_01.html">January 2025</a></li><li><hr></li><li><a title="Porting progress" href="2024_12.html">December 2024</a></li><li><a title="A new engine" href="2024_11.html">November 2024</a></li><li><a title="Leaving the prototype phase" href="2024_10.html">October 2024</a></li><li><a title="Koi farms in Japan" href="2024_09.html">September 2024</a></li><li><a title="Water & fin colors" href="2024_08.html">August 2024</a></li><li><a title="Pattern genetics" href="2024_07.html">July 2024</a></li><li><a title="The first patterns" href="2024_06.html">June 2024</a></li><li><a title="Shadows, textures and fins" href="2024_05.html">May 2024</a></li><li><a title="Animation" href="2024_04.html">April 2024</a></li><li><a title="Rigging fins" href="2024_03.html">March 2024</a></li><li><a title="Koi modelling" href="2024_02.html">February 2024</a></li><li><a title="Interactive koi" href="2024_01.html">January 2024</a></li><li><hr></li><li><a title="Moving to 3d" href="2023_12.html">December 2023</a></li><li><a title="Pond digging" href="2023_11.html">November 2023</a></li><hr></ul><a href="rss.xml" title="RSS"><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24.912 24.912"><g><path d="M3.692,17.517C1.656,17.517,0,19.173,0,21.211C0,23.244,1.656,24.9,3.692,24.9s3.694-1.657,3.694-3.689C7.387,19.173,5.729,17.517,3.692,17.517z"/><path d="M0.384,8.142C0.173,8.142,0,8.315,0,8.527v4.688c0,0.211,0.173,0.383,0.384,0.383c6.02,0,10.919,4.898,10.919,10.92c0,0.209,0.171,0.383,0.384,0.383h4.689h0.016c0.215,0,0.387-0.173,0.387-0.383l-0.018-0.121C16.692,15.423,9.37,8.142,0.384,8.142z"/><path d="M24.89,24.397C24.825,10.936,13.854,0.011,0.384,0.011C0.173,0.011,0,0.183,0,0.397v4.824c0,0.212,0.173,0.383,0.384,0.383c10.429,0,18.913,8.486,18.913,18.914c0,0.209,0.172,0.383,0.382,0.383h4.825h0.02c0.21,0,0.388-0.173,0.388-0.383L24.89,24.397z"/></g></svg></a><a href="https://x.com/jobtalle" target="_blank" title="X"><svg class="icon" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"></path></g></svg></a><a href="https://discord.gg/bw3ZFe63Qg" target="_blank" title="Discord"><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 126.644 96"><path d="M81.15,0c-1.2376,2.1973-2.3489,4.4704-3.3591,6.794-9.5975-1.4396-19.3718-1.4396-28.9945,0-.985-2.3236-2.1216-4.5967-3.3591-6.794-9.0166,1.5407-17.8059,4.2431-26.1405,8.0568C2.779,32.5304-1.6914,56.3725.5312,79.8863c9.6732,7.1476,20.5083,12.603,32.0505,16.0884,2.6014-3.4854,4.8998-7.1981,6.8698-11.0623-3.738-1.3891-7.3497-3.1318-10.8098-5.1523.9092-.6567,1.7932-1.3386,2.6519-1.9953,20.281,9.547,43.7696,9.547,64.0758,0,.8587.7072,1.7427,1.3891,2.6519,1.9953-3.4601,2.0457-7.0718,3.7632-10.835,5.1776,1.97,3.8642,4.2683,7.5769,6.8698,11.0623,11.5419-3.4854,22.3769-8.9156,32.0509-16.0631,2.626-27.2771-4.496-50.9172-18.817-71.8548C98.9811,4.2684,90.1918,1.5659,81.1752.0505l-.0252-.0505ZM42.2802,65.4144c-6.2383,0-11.4159-5.6575-11.4159-12.6535s4.9755-12.6788,11.3907-12.6788,11.5169,5.708,11.4159,12.6788c-.101,6.9708-5.026,12.6535-11.3907,12.6535ZM84.3576,65.4144c-6.2637,0-11.3907-5.6575-11.3907-12.6535s4.9755-12.6788,11.3907-12.6788,11.4917,5.708,11.3906,12.6788c-.101,6.9708-5.026,12.6535-11.3906,12.6535Z"/></svg></a></div><div id="blog"><div id="post"><h2>Going cross-platform</h2><h3>December 2025</h3><figure><img src="posts\2025_12\porting.webp" width="350" height="189" alt="A screenshot of koi farm 1 running on the Nintendo Switch"/><figcaption>Koi farm 1 running on the Nintendo Switch.</figcaption></figure><p>Porting koi farm 1 to the switch was not easy. The game runs well on it now, at the time of writing the only thing left to port is the interface. What did not help was writing the game in the most unportable mainstream language, JavaScript, so everything has to be rewritten in C++. What also doesn't help is the fact that the entire interface is basically a website, and game consoles aren't browsers, so they can't render it. These seemingly worst case language choices reflect the fact that koi farm was never made to be a game, it was just a small experiment in the browser that got out of hand.</p><p>Koi farm 2 however is designed to run on many different platforms, including the Nintendo Switch (2). The game engine is entirely written in portable C++, and it talks to the GPU using Vulkan, which the Switch supports just like Windows and Linux. Unfortunately, when we tried building koi farm 2 for the Switch this month, it did not compile. A few issues had to be resolved first.</p><ul><li>I implemented some classes that took references to static objects in their template, it turns out that was not allowed. Microsoft's compiler does allow it, which led me to assume this was valid C++, but it isn't.</li><li>Many singleton classes were static, and construct before the main function runs. This causes a whole range of issues.</li><li>The filesystem on consoles is very different, and the engine needs to support that.</li></ul><p>The game now compiles and runs on our devkit. Rendering doesn't work yet, but we'll probably figure it out very soon, which means koi farm 2 will be Switch compatible from the start. The only difference with PC versions may be slightly lower graphics settings or scene limits (koi and plant counts) to make sure it runs at 60fps, while the PC version allows for very large scenes.</p><p>I've been working on adding the procedural plant breeding system, and the gameplay mechanics require a large number of plants in a single scene; there can be thousands of unique koi, but also thousands of plants. One of the bigger challenges is rendering these plants, or rather, <em>not</em> rendering them when they're out of view. The only plants in existence so far are grass patches, and these toggle on or off based on grid cell visibility. For other plants, this can largely be the same. The difference is that grass is everywhere, but custom plants can be sparse. The grass system expects grass for almost every tile, and when a tile has no grass it emits an empty render call. This system will not scale at all, because I'd have to emit an empty render call for every <em>possible</em> plant on a tile, which would result in wasting most GPU resources by forcing it to handle empty commands. Besides, emitting empty calls at all was not very nice to begin with.</p><p>A better way to handle this is by <dfn>compacting draw calls</dfn> on the GPU. This means the GPU does the following:</p><ol><li>The GPU checks how many visible plants exist on every visible grid cell.</li><li>Then, the GPU calculates the offset of the draw calls produced by each grid cell.</li><li>The GPU iterates over all grid cells again, but instead of checking how many plants exists, it writes the draw calls for those plants to a draw call array. The offset in this array was previously calculated.</li><li>A list of draw calls for all visible plants now exists, and the GPU uses this list to draw a frame.</li></ol><p>Steps 1-3 are only executed when the camera moves or when plants are added to or removed from the scene, so for most frames, only step 4 is executed.</p><p>This approach to rendering is called <dfn>GPU driven rendering</dfn>, and it's an alternative to letting the CPU figure out what's visible and send draw calls to the GPU. The latter is simply not an option for koi farm, because there are too many potentially visible objects in a scene. This might work on a gaming PC and lots of multithreading, but it won't work on simpler computers or tablets, and it definitely won't work on older consoles. The GPU is much better at parallel tasks like iterating over all things and figuring out whether they need to be drawn.</p><figure><img src="posts\2025_12\hierarchy.webp" width="300" height="288" alt="Grid cell hierarchy"><figcaption>Grid cell hierarchy</figcaption></figure><p>Finally, to optimize rendering a bit more, I'm sorting all grid cells front to back before building the draw lists. This may seem counterintuitive, if you'd draw a painting you'd start with the background and then paint over that. For the GPU it's the other way around: if I draw something like a big rock in the foreground, the depth of that rock is written to the <dfn>depth buffer</dfn>, which makes sure that successive draw calls don't overwrite the rock if they're behind it. By drawing the rock first, I'm occluding as many pixels as possible, which prevents them from being calculated and written later. This reduces <dfn>overdraw</dfn>: overwriting pixels.</p><p>The only information the CPU now needs to prepare each frame is a list of visible grid cells. This used to be simple when the grid was flat, I projected the camera frustum on the flat ground plane and gathered all cells within it (see <a href="2025_05.html">my post from May</a>). Since <a href="2025_11.html">last month</a>, this method is no longer accurate because terrain has elevation; the cells are no longer on a flat plane. I'll have to use one of the following new methods:</p><ol><li>I can consider all cells in a scene, and cull them using a more advanced (and slow) height aware method. This doesn't scale well on its own: doubling the amount of grid cells would make it twice as slow. A better way to do this is to create a hierarchy of grid cells. The image shows an example of such a hierarchy, where every four grid cells fall under one higher level grid cell. That way culling works more efficiently. For every highest level grid cell, I check whether it's completely visible, partially visible, or completely invisible.<ul><li>If it's completely visible, all cells under it are visible.</li><li>If it's completely invisible, all cells under it are invisible.</li><li>If it's partially visible, I run the algorithm for all four cells one level down.</li></ul></li><li>I can use the GPU again to check visibility of all cells in parallel. The algorithm above can be used on the GPU as well, but it doesn't parallelize very well so culling each cell individually may be faster.</li></ol><p>While the first method feels elegant and will perform well (time complexity is logarithmic instead of quadratic), doing this work on the GPU as well may be better. The list of visible cells is only needed on the GPU after all. Generating it on the CPU and then uploading it to the GPU may be an unnecessary detour, and the CPU has plenty of work to do already.</p><p>Because a first batch of game audio will be made in 2026, I've decided to prepare the engine to play sound effects. To give the sound designer as much creative freedom as possible, I've chosen to use <dfn>Wwise</dfn>, which is one of the big game audio solutions.</p></div><div id="footer"><span class="previous"><a href="2025_11.html"><< previous</a></span><span id="copyright">© Job Talle 2023 - 2026</span></div></div></div></div></body></html>